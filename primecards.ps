%!PS
%%Creator: Harald Boegeholz
%%Title: Cards for prime number game
%%Orientation: Portrait
%%EndComments

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Configure this for different sets of cards, symbols, colours ...
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

false % set to true to produce individual pages for each card face

/cardSymbols
[   % each line produces cards with the given number, one for each 
    % element of the array
    % an element can be a single prime or an array of up to 3 primes
    % (more won't crash, but look bad)
    [ 1  [2 3 [2 2 2] 5 [2 2] 7 11 13 [2 3] 17 [3 3] 19] ]
    [ 2  [2 3 [2 2 2] 5 [2 2] 7 23 29 [2 3] 2 [3 3] 5] ]
    [ 3  [2 3 5 7 11 13 17 19 31 37 3  5] ]
    [ 4  [2 3 5 7 23 29 41 43 47 [2 2] 2 5] ]
    [ 5  [2 3 5 7 11 13 17 19 53 59 3  5] ]
    [ 6  [2 3 5 7 23 29 31 37 61 [2 3] 67 2] ]
    [ 7  [2 3 5 7 11 13 17 19 71 73 79 7] ]
    [ 8  [2 3 5 7 23 29 41 43 47 [2 2 2] 83 89] ]
    [ 9  [2 3 5 7 11 13 17 19 31 [3 3] 37 97] ]
] def

% procedures to render a symbol for each prime at the current location
/symbolProcedures
<<  % each procedure can be replaced by any code to draw a symbol
    % at current point
    2 { startSymbol (resources/2.eps) run endSymbol}
    3 { startSymbol (resources/3.eps) run endSymbol}
    5 { startSymbol (resources/5.eps) run endSymbol}
    7 { startSymbol (resources/7.eps) run endSymbol}
    11 { startSymbol (resources/11.eps) run endSymbol}
    13 { startSymbol (resources/13.eps) run endSymbol}
    17 { startSymbol (resources/17.eps) run endSymbol}
    19 { startSymbol (resources/19.eps) run endSymbol}
    23 { startSymbol (resources/23.eps) run endSymbol}
    29 { startSymbol (resources/29.eps) run endSymbol}
    31 { startSymbol (resources/31.eps) run endSymbol}
    37 { startSymbol (resources/37.eps) run endSymbol}
    41 { startSymbol (resources/41.eps) run endSymbol}
    43 { startSymbol (resources/43.eps) run endSymbol}
    47 { startSymbol (resources/47.eps) run endSymbol}
    53 { startSymbol (resources/53.eps) run endSymbol}
    59 { startSymbol (resources/59.eps) run endSymbol}
    61 { startSymbol (resources/61.eps) run endSymbol}
    67 { startSymbol (resources/67.eps) run endSymbol}
    71 { startSymbol (resources/71.eps) run endSymbol}
    73 { startSymbol (resources/73.eps) run endSymbol}
    79 { startSymbol (resources/79.eps) run endSymbol}
    83 { startSymbol (resources/83.eps) run endSymbol}
    89 { startSymbol (resources/89.eps) run endSymbol}
    97 { startSymbol (resources/97.eps) run endSymbol}
>> def

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Better don't touch this if you don't know PostScript
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

/realshowpage {showpage} bind def
/showpage {} def % this is a hack to prevent GhostScript from starting a
% new page after every execution of run. Also, the included eps files
% contain showpage operators that should be ignored.

% playing cards are 2.5 x 3.5 inches
/xstep 2.5 72 mul def
/ystep 3.5 72 mul def

{ % make card-sized pages with one card face each
    /pageWidth xstep def
    /pageHeight ystep def
    
    << /PageSize [pageWidth pageHeight] >> setpagedevice

    /xmax 0 def
    /ymax 0 def
}
{ % make A4 pages with 9 cards each
    /pageWidth 595 def
    /pageHeight 842 def

    << /PageSize [pageWidth pageHeight] >> setpagedevice

    /xmax 2 def
    /ymax 2 def
} ifelse


/xoffset pageWidth xstep xmax 1 add mul sub 2 div def
/yoffset pageHeight ystep ymax 1 add mul sub 2 div def

/stackSep 0.11 xstep mul def % vertical distance for stacked symbols

/fontCardNo
{
    /Helvetica findfont 40 scalefont setfont
} def

% Calculate the midpoint of the bounding box of a string
/stringMidpoint {
    gsave
    newpath
    0 0 moveto
    false charpath
    flattenpath
    pathbbox
    /ury exch def
    /urx exch def
    /lly exch def
    /llx exch def
    urx llx sub 2 div llx add
    ury lly sub 2 div lly add
    grestore
} def

% Show the string centered on the current point
/showCentered {
    dup stringMidpoint neg exch neg exch rmoveto
    show
} def

/rotatedShow {
    gsave
    180 rotate
    showCentered
    grestore
} def

/drawCardNo
{
    (xxx) cvs
    fontCardNo 
    showCentered
} def

/flippedCardNo
{
    (xxx) cvs
    fontCardNo 
    rotatedShow
} def


/grid
{
    0 setgray
    0.5 setlinewidth

    0 1 xmax 1 add
    {
        xstep mul xoffset add 0 moveto 0 pageHeight rlineto stroke
    } for

    0 1 ymax 1 add
    {
        ystep mul yoffset add 0 exch moveto pageWidth 0 rlineto stroke
    } for
} def

/background
{
    setgray
    xoffset yoffset moveto
    -10 -10 rmoveto
    xmax 1 add xstep mul 20 add 0 rlineto
    0 ymax 1 add ystep mul 20 add rlineto
    xmax 1 add xstep mul 20 add neg 0 rlineto
    closepath fill
} def

/startCardFront
{
    % (startCardFront) = x = y =
    x 0 eq y 0 eq and
    { % if
        grid
        1 background
        [
    } if
    gsave
    x xstep mul xoffset add ymax y sub ystep mul yoffset add translate
} def

/endCardFront
{
    grestore
    /x x 1 add def
    x xmax gt
    { % if
        /x 0 def
        /y y 1 add def
        y ymax gt
        { % if
            /x 0 def
            /y 0 def
            realshowpage
        } if
    } if
} def

/startCardBack
{
    % (startCardBack) = x = y =
    x 0 eq y 0 eq and
    { %if
        grid
        0 background
    } if
    gsave
    xmax x sub xstep mul xoffset add ymax y sub ystep mul yoffset add translate
} def

/endCardBack
{
    grestore
    /x x 1 add def
    x xmax gt
    { % if
        /x 0 def
        /y y 1 add def
        y ymax gt
        { % if
            /x 0 def
            /y 0 def
            realshowpage
        } if
    } if
} def

/startSymbolSmall
{
    gsave
    currentpoint translate 
    0.4 0.4 scale
    -24 -24 translate
} def

/startSymbolLarge
{
    gsave
    currentpoint translate
    1.5 1.5 scale
    -24 -24 translate
} def


/endSymbol
{
    grestore
} def

/drawSymbolStack
{ % expecting array of symbols on the stack
    gsave
    { % forall
        0 0 moveto
        symbolProcedures exch get exec
        0 stackSep neg translate
    } forall
    grestore
} def

/drawCardFront
{ % expecting symbol[-array] and cardno on the stack
    0.1 xstep mul 0.9 ystep mul moveto
    0 setgray
    dup drawCardNo

    0.9 xstep mul 0.1 ystep mul moveto
    0 setgray
    flippedCardNo

    dup type /arraytype ne
    { % if
        [ exch ] % turn into singleton array
    } if

    
    /startSymbol { startSymbolSmall } def

    gsave
    0.1 xstep mul 0.78 ystep mul translate
    dup drawSymbolStack
    grestore

    gsave
    0.9 xstep mul 0.22 ystep mul translate
    180 rotate
    dup drawSymbolStack
    grestore

    % /startSymbol { startSymbolLarge } def
    gsave
    0.5 xstep mul 0.5 ystep mul translate
    3.2 3.2 scale
    dup length 1 sub stackSep mul 2 div 0 exch translate
    drawSymbolStack
    grestore
} def

/drawCardBack
{ % expecting symbols and cardno on the stack
    0.1 xstep mul 0.9 ystep mul moveto
    1 setgray
    dup drawCardNo

    0.9 xstep mul 0.1 ystep mul moveto
    1 setgray
    flippedCardNo
    
    % symbols array is on top of stack
    dup length
    360 exch div /delta exch def
    
    /startSymbol { startSymbolSmall } def

    /alpha 0 def
    /radius 0.3 xstep mul def
    % symbols array is still on top of stack
    { % forall
        dup type /arraytype ne
        { % if
            [ exch ] % make it into a singleton array
        } if
        dup length 1 sub stackSep mul 2 div radius exch sub /r exch def
        { % forall
            0.5 xstep mul 0.5 ystep mul moveto
            alpha cos r mul alpha sin r mul rmoveto
            symbolProcedures exch get exec
            /r r stackSep add def
        } forall

        /alpha alpha delta add def
    } forall
} def

/flushDeferredCards
{
    ]
    {
        startCardBack
        aload pop
        drawCardBack
        endCardBack
    } forall
} def

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% main loop to produce all cards
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

/x 0 def
/y 0 def

cardSymbols
{ % forall
    aload pop
    /symbols exch def
    /cardno exch def

    symbols
    { % forall
        /prime exch def
        startCardFront
        prime cardno drawCardFront
        endCardFront

        [ % defer painting the back of the card
            symbols cardno
        ] 
        
        x 0 eq y 0 eq and
        {
            flushDeferredCards
        } if
    } forall
} forall

x 0 eq y 0 eq and not
{ % if
    /x 0 def /y 0 def
    realshowpage
    flushDeferredCards
    realshowpage
} if

%%EOF
