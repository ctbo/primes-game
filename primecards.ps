%!PS
%%Creator: Harald Boegeholz
%%Title: Cards for prime number game
%%Orientation: Portrait
%%EndComments

true % set to true to produce individual pages for each card face

/realshowpage {showpage} bind def
/showpage {} def % this is a hack to prevent GhostScript from starting a
% new page after every execution of run. Also, the included eps files
% contain showpage operators that should be ignored.

(common.ps) run % include definitions of cards and symbols

/mm { 25.4 div 72 mul } def

% playing cards are 84 mm x 89 mm (2.5 x 3.5 inches)
/xstep 64 mm def
/ystep 89 mm def

{ % make card-sized pages with one card face each
    % printing service requires 3 mm bleed on each side
    /pageWidth xstep 6 mm add def
    /pageHeight ystep 6 mm add def
    
    << /PageSize [pageWidth pageHeight] >> setpagedevice

    /xmax 0 def
    /ymax 0 def
}
{ % make A4 pages with 9 cards each
    /pageWidth 595 def
    /pageHeight 842 def

    << /PageSize [pageWidth pageHeight] >> setpagedevice

    /xmax 2 def
    /ymax 2 def
} ifelse


/xoffset pageWidth xstep xmax 1 add mul sub 2 div def
/yoffset pageHeight ystep ymax 1 add mul sub 2 div def

/stackSep 0.11 xstep mul def % vertical distance for stacked symbols

/fontCardNo
{
    /Helvetica findfont 40 scalefont setfont
} def

% Calculate the midpoint of the bounding box of a string
/stringMidpoint {
    gsave
    newpath
    0 0 moveto
    false charpath
    flattenpath
    pathbbox
    /ury exch def
    /urx exch def
    /lly exch def
    /llx exch def
    urx llx sub 2 div llx add
    ury lly sub 2 div lly add
    grestore
} def

% Show the string centered on the current point
/showCentered {
    dup stringMidpoint neg exch neg exch rmoveto
    show
} def

/rotatedShow {
    gsave
    180 rotate
    showCentered
    grestore
} def

/drawCardNo
{
    (xxx) cvs
    fontCardNo 
    showCentered
} def

/flippedCardNo
{
    (xxx) cvs
    fontCardNo 
    rotatedShow
} def


/grid
{
    0 setgray
    0.5 setlinewidth

    0 1 xmax 1 add
    {
        xstep mul xoffset add 0 moveto 0 pageHeight rlineto stroke
    } for

    0 1 ymax 1 add
    {
        ystep mul yoffset add 0 exch moveto pageWidth 0 rlineto stroke
    } for
} def

/background
{
    setgray
    xoffset yoffset moveto
    -3 mm -3 mm rmoveto
    xmax 1 add xstep mul 6 mm add 0 rlineto
    0 ymax 1 add ystep mul 6 mm add rlineto
    xmax 1 add xstep mul 6 mm add neg 0 rlineto
    closepath fill
} def

/startCardFront
{
    % (startCardFront) = x = y =
    x 0 eq y 0 eq and
    { % if
        grid
        1 background
        [
    } if
    gsave
    x xstep mul xoffset add ymax y sub ystep mul yoffset add translate
} def

/endCardFront
{
    grestore
    /x x 1 add def
    x xmax gt
    { % if
        /x 0 def
        /y y 1 add def
        y ymax gt
        { % if
            /x 0 def
            /y 0 def
            % xoffset yoffset moveto xstep 0 rlineto 0 ystep rlineto xstep neg 0 rlineto closepath 0.5 setlinewidth 1 0 0.5 setrgbcolor stroke
            realshowpage
        } if
    } if
} def

/startCardBack
{
    % (startCardBack) = x = y =
    x 0 eq y 0 eq and
    { %if
        grid
        0 background
    } if
    gsave
    xmax x sub xstep mul xoffset add ymax y sub ystep mul yoffset add translate
} def

/endCardBack
{
    grestore
    /x x 1 add def
    x xmax gt
    { % if
        /x 0 def
        /y y 1 add def
        y ymax gt
        { % if
            /x 0 def
            /y 0 def
            % xoffset yoffset moveto xstep 0 rlineto 0 ystep rlineto xstep neg 0 rlineto closepath 0.5 setlinewidth 1 0 0.5 setrgbcolor stroke
            realshowpage
        } if
    } if
} def

/startSymbolSmall
{
    gsave
    currentpoint translate 
    0.4 0.4 scale
    -24 -24 translate
} def

/startSymbolLarge
{
    gsave
    currentpoint translate
    1.5 1.5 scale
    -24 -24 translate
} def


/endSymbol
{
    grestore
} def

/drawSymbolStack
{ % expecting array of symbols on the stack
    gsave
    { % forall
        0 0 moveto
        symbolProcedures exch get exec
        0 stackSep neg translate
    } forall
    grestore
} def

/drawCardFront
{ % expecting symbol[-array] and cardno on the stack
    0.11 xstep mul 0.9 ystep mul moveto
    0 setgray
    dup drawCardNo

    0.89 xstep mul 0.1 ystep mul moveto
    0 setgray
    flippedCardNo

    dup type /arraytype ne
    { % if
        [ exch ] % turn into singleton array
    } if

    
    /startSymbol { startSymbolSmall } def

    gsave
    0.1 xstep mul 0.78 ystep mul translate
    dup drawSymbolStack
    grestore

    gsave
    0.9 xstep mul 0.22 ystep mul translate
    180 rotate
    dup drawSymbolStack
    grestore

    % /startSymbol { startSymbolLarge } def
    gsave
    0.5 xstep mul 0.5 ystep mul translate
    3.2 3.2 scale
    dup length 1 sub stackSep mul 2 div 0 exch translate
    drawSymbolStack
    grestore
} def

/drawCardBack
{ % expecting symbols and cardno on the stack
    0.11 xstep mul 0.9 ystep mul moveto
    1 setgray
    dup drawCardNo

    0.89 xstep mul 0.1 ystep mul moveto
    1 setgray
    flippedCardNo
    
    % symbols array is on top of stack
    dup length
    360 exch div /delta exch def
    
    /startSymbol { startSymbolSmall } def

    /alpha 0 def
    /radius 0.3 xstep mul def
    % symbols array is still on top of stack
    { % forall
        dup type /arraytype ne
        { % if
            [ exch ] % make it into a singleton array
        } if
        dup length 1 sub stackSep mul 2 div radius exch sub /r exch def
        { % forall
            0.5 xstep mul 0.5 ystep mul moveto
            alpha cos r mul alpha sin r mul rmoveto
            symbolProcedures exch get exec
            /r r stackSep add def
        } forall

        /alpha alpha delta add def
    } forall
} def

/flushDeferredCards
{
    ]
    { % forall
        startCardBack
        aload pop
        drawCardBack
        endCardBack
    } forall
} def

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% main loop to produce all cards
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

/x 0 def
/y 0 def

cardSymbols
{ % forall
    aload pop
    /symbols exch def
    /cardno exch def

    symbols
    { % forall
        /prime exch def
        startCardFront
        prime cardno drawCardFront
        endCardFront

        [ % defer painting the back of the card
            symbols cardno
        ] 
        
        x 0 eq y 0 eq and
        {
            flushDeferredCards
        } if
    } forall
} forall

x 0 eq y 0 eq and not
{ % if
    /x 0 def /y 0 def
    realshowpage
    flushDeferredCards
    realshowpage
} if

%%EOF
